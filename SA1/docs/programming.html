<!DOCTYPE html>
<html>
<head>
  <title> programming.html</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<p><em>This document is still work in progress and any help would be appreciated!</em></p>
<h1>
<a id="user-content-programming" class="anchor" href="#programming" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Programming</h1>
<p>Contrary to another SA-1 activation patches, SA-1 Pack relies on memory remapping,
which has the absurd advantage of being able to move most of the game logic routines
to the SA-1 CPU. It involves though some compatibility problems with ROM hacks that
weren't prepared for using the SA-1 Pack.</p>
<h2>
<a id="user-content-memory-remap" class="anchor" href="#memory-remap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Memory remap</h2>
<p>The main thing you need to do, regardless if you plan to your code run on SA-1 CPU or
SNES CPU is RAM remapping your defines.</p>
<p>Direct Map addresses:</p>
<p><code>$7E:0000</code>-<code>$7E:00FF</code> -&gt; <code>$00:3000</code>-<code>$00:30FF</code></p>
<p>If you are using <code>dp</code> addressing mode, Direct Page is set to $3000 automatically and you
won't need to change your opcode, with the exception of addresses that use <code>addr</code> or <code>long</code>
addressing mode. For example:</p>
<p>LDA $00 -&gt; LDA $00 (nothing changed)
LDA $0000,y -&gt; LDA $3000,y
LDA $000000,x -&gt; LDA $003000,x</p>
<p><strong>Careful to the opcode context!</strong> On the last example if X is 16-bit and it has a value
like $8000, probably your code is reading ROM instead! On that case, nothing should be
changed at all.</p>
<p><code>$7E:0100</code>-<code>$7E:1FFF</code> -&gt; <code>$40:0100</code>-<code>$40:1FFF</code></p>
<p>Since the stack is only used by the SNES CPU (the SA-1 CPU has its own), it has been moved to
<code>$7E:1FFF</code>. Therefore <code>$40:610E</code>-<code>$40:61FF</code> is free to be used.</p>
<p>Banks $40 to $4F has the BW-RAM. BW-RAM is similar to SRAM, but it means "backup and work RAM"
instead of "static RAM". On the LoROM banks, $0000-$1FFF is a mirror to the WRAM and that can't
be changed. So for local addresses, the remap will be:</p>
<p><code>$0100</code>-<code>$1FFF</code> -&gt; <code>$6100</code>-<code>$7FFF</code>.</p>
<p>Examples:</p>
<p>If data bank is $00-$3F or $80-$BF (LoROM banks):
LDA $0100 -&gt; LDA $6100</p>
<p>Otherwise:
LDA $7E0100 -&gt; LDA $400100</p>
<p>If data bank is $7E, change the data bank to $40 and don't change the opcode.</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">7E</span>
<span class="pl-en">PHA</span>
<span class="pl-en">PLB</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">0100</span></pre></div>
<p>-&gt;</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">40</span>
<span class="pl-en">PHA</span>
<span class="pl-en">PLB</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">0100</span></pre></div>
<p>Additionally, we have the following remaps:</p>
<p><code>$7E:C800</code>-<code>$7E:FFFF</code> to <code>$40:C800</code>-<code>$40:FFFF</code>.<br>
<code>$7F:C800</code>-<code>$7E:FFFF</code> to <code>$41:C800</code>-<code>$41:FFFF</code>.</p>
<p><code>$7F:9A7B</code>-<code>$7F:9C7A</code> to <code>$41:8800</code>-<code>$41:89FF</code>.</p>
<p><code>$70:0000</code>-<code>$70:07FF</code> to <code>$41:C000</code>-<code>$41:C7FF</code>.</p>
<p>Also, note that <code>$70:0800</code>-<code>$70:27FF</code> is now
<code>$41:A000</code>-<code>$41:BFFF</code> if you want more SRAM, but only that
much. 16 KB should be enough for SRAM unless you're working
on something that really wastes space. Alternatively, you
can use MarioE/LX5's BW-RAM plus patch, which makes the job
easier.</p>
<p>For more information, see the Memory Map Summary file
located in docs folder. It also contains information about
the remapped sprite tables, which will likely cause problem
if you don't use a special remapping for them.</p>
<h2>
<a id="user-content-the-sa-1-memory-map" class="anchor" href="#the-sa-1-memory-map" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The SA-1 memory map</h2>
<p>Now, knowing all the SRAM/RAM mapping changes, you may
ask: what is the data at <code>$40:0000</code>-<code>$41:FFFF</code>
and <code>$XX:3000</code>+ for?</p>
<p>When you activate SA-1, two types of RAM are added
and one is deleted. In other words, I-RAM and BW-RAM
are added while SRAM is deleted.</p>
<h3>
<a id="user-content-i-ram" class="anchor" href="#i-ram" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>I-RAM</h3>
<p>I-RAM is SA-1 Internal RAM, which is why it's called I-RAM.
The I-RAM runs at 10.74 MHz with no delay and is the
fastest RAM of SNES, with exception of Super FX's cache.
But since cache isn't RAM, that doesn't count.
The size of I-RAM is 2 KB (2048 bytes) and it's
located in banks <code>$00</code>-<code>$3F</code> and <code>$80</code>-<code>$BF</code>, in the
<code>$3000</code>-<code>$37FF</code> range.</p>
<p><code>$3000</code>-<code>$30FF</code> is same as <code>$7E:0000</code>-<code>$7E:00FF</code> on SMW,
which increases the read/write speed by 4 times.
The game will access it even when running code from the
SNES side, because the Direct Page is now at <code>$3000</code>.</p>
<p><code>$3100</code>-<code>$31FF</code> is internally used by my patch for
various purposes.</p>
<p><code>$3200</code>-<code>$3425</code> is used by Arujus's more sprites patch!<br>
<code>$3426</code>-<code>$36FF</code> is free to use.<br>
<code>$3700</code>-<code>$377F</code> is the Character Conversion DMA buffer.<br>
<code>$3780</code>-<code>$37FF</code> is the SA-1 stack.</p>
<p>A detailed I-RAM map is available <a href="I-RAM.html">here</a>.</p>
<p>I-RAM is recommended to be used for RAM codes or as a place
for storing data which is accessed many times, since it'll
be accessed much faster than other type of RAM.</p>
<h3>
<a id="user-content-bw-ram" class="anchor" href="#bw-ram" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BW-RAM</h3>
<p>BW-RAM is SA-1's SRAM. As simple as that. But unlike the
SRAM (which means Static or Saveable RAM), BW-RAM means
Backup and Work RAM. In other words, BW-RAM is a
RAM created for both working and saving. I don't think
its purposes change that much, but could BW-RAM be a little
faster than SRAM..? I don't know.</p>
<p>BW-RAM runs at 5.37 MHz and is mapped to banks <code>$40</code>-<code>$4F</code>.
You can expand the BW-RAM size to 256 KB, according to the
SNES Dev. Manual Book II, but I only got up to 128 KB working,
perhaps because none of the emulators implemented that, or
no SA-1 game ever used 256 KB of BW-RAM.</p>
<p>This patch always uses the maximum BW-RAM size possible
(128 KB) in banks <code>$40</code>-<code>$41</code>. <code>$42</code>-<code>$FF</code> will mirror the first two
banks (e.g <code>$42</code> and <code>$40</code>, <code>$43</code> and <code>$41</code>, etc).</p>
<p>I remapped most RAM on SMW to BW-RAM and the SRAM of course.
For more details, check <a href="BW-RAM.html">this</a>.</p>
<p>Of course, if the BW-RAM is at bank <code>$40</code>+ now, where has the
ROM been moved to?</p>
<h3>
<a id="user-content-rom" class="anchor" href="#rom" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ROM</h3>
<p>The ROM map changed in rather complex way. Look:</p>
<table>
<thead>
<tr>
<th>Bank Range</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>$00</code>-<code>$1F</code>
</td>
<td>ROM (CXB) (LoROM)</td>
</tr>
<tr>
<td>
<code>$20</code>-<code>$3F</code>
</td>
<td>ROM (DXB) (LoROM)</td>
</tr>
<tr>
<td>
<code>$40</code>-<code>$4F</code>
</td>
<td>BW-RAM</td>
</tr>
<tr>
<td>
<code>$50</code>-<code>$5F</code>
</td>
<td>Unmapped</td>
</tr>
<tr>
<td>
<code>$60</code>-<code>$6F</code>
</td>
<td>(SA-1 only) "Virtual" BW-RAM.</td>
</tr>
<tr>
<td>
<code>$70</code>-<code>$7D</code>
</td>
<td>Unmapped</td>
</tr>
<tr>
<td>
<code>$7E</code>-<code>$7F</code>
</td>
<td>(SNES only) WRAM/Work RAM</td>
</tr>
<tr>
<td>
<code>$80</code>-<code>$9F</code>
</td>
<td>ROM (EXB) (LoROM)</td>
</tr>
<tr>
<td>
<code>$A0</code>-<code>$BF</code>
</td>
<td>ROM (FXB) (LoROM)</td>
</tr>
<tr>
<td>
<code>$C0</code>-<code>$CF</code>
</td>
<td>ROM (CXB) (HiROM)</td>
</tr>
<tr>
<td>
<code>$D0</code>-<code>$DF</code>
</td>
<td>ROM (DXB) (HiROM)</td>
</tr>
<tr>
<td>
<code>$E0</code>-<code>$EF</code>
</td>
<td>ROM (EXB) (HiROM)</td>
</tr>
<tr>
<td>
<code>$F0</code>-<code>$FF</code>
</td>
<td>ROM (FXB) (HiROM)</td>
</tr>
</tbody>
</table>
<p>Now the ROM is split into various locations, which
may act as LoROM or HiROM, and each part has an "ID", which
can be CXB, DXB, EXB or FXB. Those belong to the ROM area,
and their content may vary depending on what the bank switch
value is, which is set using the SA-1 registers <code>$2220</code>-<code>$2223</code>.
But my patch already takes care of that.</p>
<p>If the ROM is 4 MB or less, <code>$00</code>-<code>$3F</code> and <code>$80</code>-<code>$BF</code> will map to
the 1st&amp;2nd MB and the 3rd&amp;4th MB respectively. <code>$C0</code>-<code>$FF</code> will be
the HiROM area mirroring the same 4MB of data.</p>
<p>If the ROM is 5-8MB, the first 4MB are mapped to <code>$00</code>-<code>$3F</code> and <code>$80</code>-<code>$BF</code>
and the last 4MB of the ROM are mapped to <code>$C0</code>-<code>$FF</code>. Yeah, that will
make the first 4MB LoROM only and the last 4MB HiROM only.
This way you can access all the 8MB at once, though some emulators
may have some problems with it.</p>
<p>This also means that FastROM addressing will not work, so pay
attention to any strange jump to the <code>$808000</code>+ area, and subtract
<code>$800000</code> from those.</p>
<p>Xkas doesn't support SA-1 mapping and because of that you'll
be fine using it only for patching in the first 2MB area.</p>
<p>You can try using <code>org $408000</code> or <code>org $C00000</code> with <code>base $808000</code>,
but xkas doesn't really like the base command that much.</p>
<p>Using Asar, you can access all the SA-1 data, but you will need to
switch the mapping every time you're accessing an area outside
of the current range.</p>
<p>Example:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">sa1rom </span><span class="pl-c1">0</span><span class="pl-s1">,</span><span class="pl-c1">1</span><span class="pl-s1">,</span><span class="pl-c1">2</span><span class="pl-s1">,</span><span class="pl-c1">3</span><span class="pl-c"> ; access the first 4MB</span>

<span class="pl-en">org</span> <span class="pl-c1">$</span><span class="pl-c1">018000</span><span class="pl-c"> ; hijack something</span>
<span class="pl-en">	JSL CustomCode</span><span class="pl-c"> ; and run the custom code...</span>

<span class="pl-en">sa1rom </span><span class="pl-c1">4</span><span class="pl-s1">,</span><span class="pl-c1">5</span><span class="pl-s1">,</span><span class="pl-c1">6</span><span class="pl-s1">,</span><span class="pl-c1">7</span>

<span class="pl-en">org</span> <span class="pl-c1">$</span><span class="pl-en">C00000</span>
<span class="pl-en">CustomCode:</span><span class="pl-c"> ;*put code here*;</span>
<span class="pl-en">	RTL</span></pre></div>
<p>However freecode/freedata will not work with Asar when you are
accessing the 4MB+ area, atleast until Alcaro adds "bigsa1rom"
to Asar (if it wasn't implemented it already).</p>
<h2>
<a id="user-content-using-the-sa-1-cpu" class="anchor" href="#using-the-sa-1-cpu" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using the SA-1 CPU</h2>
<p>Now that you know how the memory (ROM/RAM) works,
you may ask: How can I invoke SA-1?</p>
<h3>
<a id="user-content-invoking-sa-1" class="anchor" href="#invoking-sa-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Invoking SA-1</h3>
<p>Going into SA-1 mode is really easy.
Store the 24-bit address to jump to into <code>$3180</code>-<code>$3182</code> and
then <code>JSR</code> to <code>$1E80</code>, i.e.:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA.b #Label</span><span class="pl-c">				; \ Put the address</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3180</span><span class="pl-c">				;  | to jump in</span>
<span class="pl-en">LDA.b #Label&gt;&gt;</span><span class="pl-c1">8</span><span class="pl-c">				;  | $3180 - $3182.</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3181</span><span class="pl-c">				;  |</span>
<span class="pl-en">LDA.b #Label&gt;&gt;</span><span class="pl-c1">16</span><span class="pl-c">			;  |</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3182</span><span class="pl-c">				; /</span>
<span class="pl-en">JSR</span> <span class="pl-c1">$</span><span class="pl-en">1E80</span><span class="pl-c">				; Invoke SA-1 and wait to finish.</span>
<span class="pl-c1">[...]</span><span class="pl-c">					; *other code*</span>

<span class="pl-en">Label:</span>
<span class="pl-en">PHB</span><span class="pl-c">					; \ Set Bank</span>
<span class="pl-en">PHK</span><span class="pl-c">					;  |</span>
<span class="pl-en">PLB</span><span class="pl-c">					; /</span>
<span class="pl-c">; *The SA-1 CPU runs here.*</span>
<span class="pl-en">PLB</span><span class="pl-c">					; Restore Bank</span>
<span class="pl-en">RTL</span><span class="pl-c">					; Return.</span></pre></div>
<p>So if you wanted to jump to the address <code>$00974C</code>, you'd do this:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">4C</span><span class="pl-c">				; \ Low</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3180</span><span class="pl-c">				; /</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">97</span><span class="pl-c"> 				; \ High</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3181</span><span class="pl-c">				; /</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">00</span><span class="pl-c">				; \ Bank (in this case STZ $3182 would work better)</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3182</span><span class="pl-c"> 				; /</span>
<span class="pl-en">JSR</span> <span class="pl-c1">$</span><span class="pl-en">1E80</span><span class="pl-c">				; Invoke SA-1</span></pre></div>
<h3>
<a id="user-content-simple-paralellism" class="anchor" href="#simple-paralellism" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simple paralellism</h3>
<p>You can do multi-threaded operation too:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA.b #Label</span><span class="pl-c">				; \ Put the address</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3180</span><span class="pl-c">				;  | to jump in</span>
<span class="pl-en">LDA.b #Label&gt;&gt;</span><span class="pl-c1">8</span><span class="pl-c">				;  | $3180 - $3182.</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3181</span><span class="pl-c">				;  |</span>
<span class="pl-en">LDA.b #Label&gt;&gt;</span><span class="pl-c1">16</span><span class="pl-c">			;  |</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3182</span><span class="pl-c">				; /</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">80</span><span class="pl-c">				; \ Invoke SA-1</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2200</span><span class="pl-c">				; /</span>
<span class="pl-c">; Do stuff while SA-1 is executing Label.</span>
<span class="pl-en">JSR</span> <span class="pl-c1">$</span><span class="pl-en">1E85</span><span class="pl-c">				; Wait SA-1 if it didn't finished its operation.</span>
<span class="pl-c1">[...]</span><span class="pl-c">					; *other code*</span>

<span class="pl-en">Label:</span>
<span class="pl-en">PHB</span><span class="pl-c">					; \ Set Bank</span>
<span class="pl-en">PHK</span><span class="pl-c">					;  |</span>
<span class="pl-en">PLB</span><span class="pl-c">					; /</span>
<span class="pl-c">; *The SA-1 CPU runs here.*</span>
<span class="pl-en">PLB</span><span class="pl-c">					; Restore Bank</span>
<span class="pl-en">RTL</span><span class="pl-c">					; Return.</span></pre></div>
<p>This operation may be really useful, but be careful that if
you access the ROM in multi-threading mode, SA-1 may access
it at 5.37 MHz, decreasing processing speed.</p>
<p>To make sure that SA-1 will run at full speed, place the code
in WRAM and run it from there instead.</p>
<h3>
<a id="user-content-sa-1-memory-access-caveats" class="anchor" href="#sa-1-memory-access-caveats" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SA-1 memory access caveats</h3>
<p>When you switch to SA-1 side, the system works a bit differently:</p>
<ul>
<li>
<p>You can't access the PPU and CPU registers,
which are located at <code>$2100</code>-<code>$21FF</code>, <code>$4200</code>-<code>$42FF</code> and around <code>$4000</code> too.</p>
</li>
<li>
<p>You can't access WRAM (Work RAM) in banks <code>$7E</code> and <code>$7F</code>.
Also <code>$0000</code>-<code>$07FF</code> are mapped to I-RAM instead, while
<code>$0800</code>-<code>$1FFF</code> is unused.</p>
</li>
<li>
<p>You can access the <code>$600000</code>-<code>$6FFFFF</code> range, which is the "Virtual"
BW-RAM.</p>
</li>
<li>
<p>The CPU runs 4x times faster than usual, specifically at 10.74 MHz
instead of 2.68 or 3.56 MHz (FastROM).</p>
</li>
</ul>
<p>Since you can't access the other CPU registers, you'd think to be
unable to do DMA and Multiplication/Division, right? FALSE! You'll be
able to use the SA-1 registers located at <code>$2200</code>-<code>$23FF</code>!</p>
<p>Plus the Multiplication and DMA registers available using SA-1
are much faster than the SNES ones. But you can't DMA to VRAM or
any other PPU register, since while on SA-1 side, you can only access
the cart contents (ROM, BW-RAM, I-RAM and SA-1 Registers).</p>
<h3>
<a id="user-content-multiplication-on-sa-1-cpu" class="anchor" href="#multiplication-on-sa-1-cpu" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multiplication on SA-1 CPU</h3>
<p>To execute a multiplication, do this:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">00</span><span class="pl-c">				; \ Set Multiplication Mode.</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2250</span><span class="pl-c">				; /</span>

<span class="pl-k">REP</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-c1">20</span><span class="pl-c">				; 16-bit Accum</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">XXXX</span><span class="pl-c"> 				; \ Set first multiplicand</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2251</span><span class="pl-c">				; /</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">YYYY</span><span class="pl-c"> 				; \ Set second multiplicand</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2253</span><span class="pl-c">				; /</span>

<span class="pl-k">NOP</span><span class="pl-c">     				; \ ... Wait 5 cycles!</span>
<span class="pl-en">BRA</span> <span class="pl-c1">$</span><span class="pl-c1">00</span><span class="pl-c"> 				; /</span>

<span class="pl-c">; Then can you read the product from $2306, $2307, $2308 and $2309.</span>
<span class="pl-c">; Yes, the product of SA-1 Multiplication is 32-bit! Awesome, isn't it?</span>
<span class="pl-c">; While in SNES it's 8-bit x 8-bit = 16-bit, in SA-1 it is</span>
<span class="pl-c">; 16-bit x 16-bit = 32-bit. And you only need to wait 5 cycles</span>
<span class="pl-c">; which is ~62% of a NOP in SNES!</span></pre></div>
<h3>
<a id="user-content-division-on-sa-1-cpu" class="anchor" href="#division-on-sa-1-cpu" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Division on SA-1 CPU</h3>
<p>To execute a division, do this:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">01</span><span class="pl-c">				; \ Set Division Mode</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2250</span><span class="pl-c"> 				; /</span>

<span class="pl-k">REP</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-c1">20</span><span class="pl-c">				; 16-bit Accum</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">XXXX</span><span class="pl-c">				; \ Set dividend</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2251</span><span class="pl-c">				; /</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">YYYY</span><span class="pl-c">				; \ Set divisor</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2253</span><span class="pl-c">				; /</span>

<span class="pl-k">NOP</span><span class="pl-c">     				; \ ... Wait 5 cycles!</span>
<span class="pl-en">BRA</span> <span class="pl-c1">$</span><span class="pl-c1">00</span><span class="pl-c"> 				; /</span>

<span class="pl-c">; Then you can read the division result from $2306 &amp; $2307</span>
<span class="pl-c">; and the remainder from $2308 &amp; $2309</span></pre></div>
<h3>
<a id="user-content-cpu-context" class="anchor" href="#cpu-context" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CPU context</h3>
<p>SA-1 Pack already uses the SA-1 CPU extensively and enables it on certain
portions.</p>
<p>When coding and using some CPU specific operations like SNES registers or
SA-1 multiplication, you should be aware if you are executing on the correct
CPU. Sometimes your code will already be running on the SA-1 CPU or vice-versa.</p>
<p>SA-1 Pack sets the processor to SA-1 on the following situations:</p>
<ul>
<li>sprite main and init codes;</li>
<li>generators;</li>
<li>shooters;</li>
<li>sprite level loading;</li>
<li>most of the layer level loading;</li>
<li>player physics;</li>
<li>status bar;</li>
<li>blocks;</li>
<li>misc. sprites: cluster, run-once, extended, minor, etc.;</li>
<li>pretty much the entire overworld; and</li>
<li>windowing effects.</li>
</ul>
<p>SA-1 Pack DOES NOT set the processor to SA-1:</p>
<ul>
<li>levelASM/uberASM code points: init, main, load, nmi, global code, etc.;</li>
<li>nmi</li>
<li>message boxes;</li>
<li>anything stripe image related; and</li>
<li>animations;</li>
</ul>
<p>Note: not all of the information is accurate. It's always good to test the
processor when you are developing and are not sure which processor runs there.</p>
<p>You can do that by checking if the stack pointer high byte is greater or equal #$37.
If you found any mistake, please let me know and I'll correct this document.</p>
<h3>
<a id="user-content-process-flow" class="anchor" href="#process-flow" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Process flow</h3>
<p>Other enhancement chips may work like a slave, because the
SNES sends a command to the chip, which then sends back the
result. But with SA-1 is different story, since both chips
can have interrupts so there's no slave in this case!</p>
<p>How can this be useful? When you can't access something from SA-1 side,
of course. Using this method, you can make a quick access on something
from SNES side, then come back with the value. Example: SA-1 wants to
read from an APU port, but it can't access it. To make it accessible,
call the the SNES so you can read from the APU port and then send
the value to SA-1. See below:</p>
<h4>
<a id="user-content-invoking-the-snes-from-sa-1-cpu" class="anchor" href="#invoking-the-snes-from-sa-1-cpu" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Invoking the SNES from SA-1 CPU</h4>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA.B #.SNES</span><span class="pl-c">				; \ Put the SNES pointer to run</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">0183</span><span class="pl-c">				; | in $0183-$0185.</span>
<span class="pl-en">LDA.B #.SNES/</span><span class="pl-c1">256</span><span class="pl-c">			; |</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">0184</span><span class="pl-c">				; | (Remember that $0000-$07FF</span>
<span class="pl-en">LDA.B #.SNES/</span><span class="pl-c1">65536</span><span class="pl-c">			; |  is same as $3000-$37FF).</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">0185</span><span class="pl-c">				; /</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">D0</span><span class="pl-c">				; \ Invoke/Call SNES</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2209</span><span class="pl-c">				; /</span>
<span class="pl-en">.</span><span class="pl-k">Wait</span><span class="pl-c">					; \ Wait for SNES.</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-en">018A</span><span class="pl-c">				; |</span>
<span class="pl-en">BEQ .</span><span class="pl-k">Wait</span><span class="pl-c">				; |</span>
<span class="pl-en">STZ</span> <span class="pl-c1">$</span><span class="pl-en">018A</span><span class="pl-c">				; /</span>
<span class="pl-c">; Now APU value is at $0100-$0103, because:</span>

<span class="pl-en">.SNES</span><span class="pl-c">					; SNES code</span>
<span class="pl-c">;PHB					; \ Set Bank (not really required to access RAM)</span>
<span class="pl-c">;PHK					; |</span>
<span class="pl-c">;PLB					; /</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">2140</span><span class="pl-c">				; \ Read $2140-$2143</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3100</span><span class="pl-c">				; | and save in $3100-$3103</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">2141</span><span class="pl-c">				; | (Remember that $0000-$07FF is</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3101</span><span class="pl-c">				; | NOT same as $3000-$37FF in SNES!)</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">2142</span><span class="pl-c">				; |</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3102</span><span class="pl-c">				; |</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">2143</span><span class="pl-c">				; |</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">3103</span><span class="pl-c">				; /</span>
<span class="pl-c">;PLB					; Restore Bank</span>
<span class="pl-en">RTL</span><span class="pl-c">					; Return.</span></pre></div>
<p>Using said method you can get rid of almost all SA-1
limitations, but remember that the SNES's core speed is 2.68 MHz,
so if you call it too many times, you may waste some time.</p>
<h2>
<a id="user-content-using-the-parallel-mode" class="anchor" href="#using-the-parallel-mode" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using the Parallel Mode</h2>
<p>Additionally, there's a special mode called Parallel/Background Mode.
It runs a certain code periodically while the SA-1 CPU is idle.</p>
<p>To enable it, put the code pointer to <code>$3186</code>-<code>$3188</code> and set <code>$318B</code> to <code>#$01</code>.
Unlike other modes, you have to threat this one differently:</p>
<ol>
<li>
<p>You must reserve a RAM area to use it, since other code can potentially
use it at any time. In other words, you can't use the standard RAM addresses
or your RAM writes will end up corrupted when another code gets executed by
the chip or even by SNES CPU. For these reasons, I reserved 32 bytes at
<code>$31E0</code>-<code>$31FF</code> just for Parallel Mode, so you can put your scratch values without
having risk of it getting corrupted suddenly.</p>
</li>
<li>
<p>Direct Page is set to <code>$0100</code>, since you usually will not access standard
direct page area (<code>$3000</code>-<code>$30FF</code>) and with that you will have facility with
accessing Parallel Mode reserved RAM as well other SA-1 Pack internal RAM
addresses. Of course after running your code, you should restore it back
to <code>$0100</code> if you changed it. Oh and if you're wondering, in the <strong>SA-1 CPU</strong>,
<code>$0100</code> is same thing as <code>$3100</code>. Don't get confused.</p>
</li>
<li>
<p>When accessing registers (or any other not thread-safe address), you must
disable IRQ (by using SEI opcode), to stop SA-1 from listening from SNES CPU.
With that, you can access the multiplications registers or execute a DMA
without having the risk of it getting conflicted by another thread. Don't forget
to use CLI to re-enable IRQ or otherwise the game will freeze.</p>
</li>
<li>
<p>Is preferred to your code work rather as a service, which runs code on demand.
This mode is useful for code that does, for example, graphics manipulation so it
won't access in-game performance because it ONLY uses SA-1 idle cycles and when
the game code is running its code gets paused.</p>
</li>
<li>
<p>If the status flag (318B) is set to <code>#$FF</code>, the service MUST stop current
operations and gets free to an another parallel service start executing. Because
obviously only one parallel mode code can be ran at once (I may change that in the
future but I don't think it will be ever needed).</p>
</li>
</ol>
<p>Example code (invoking parallel mode):</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">	LDA</span> <span class="pl-c1">$</span><span class="pl-en">318B</span><span class="pl-c">		; \ If there's no Parallel Mode running already,</span>
<span class="pl-en">	BEQ </span><span class="pl-s1">+</span><span class="pl-c">			; / skip.</span>

<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">FF</span><span class="pl-c">		; \ Tell previous Parallel Mode code to exit.</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-en">318B</span><span class="pl-c">		; / This is important or the game may crash or stop working.</span>

<span class="pl-s1">-</span><span class="pl-en">	LDA</span> <span class="pl-c1">$</span><span class="pl-en">318B</span><span class="pl-c">		; \ Wait until the previous server gets free.</span>
<span class="pl-en">	BNE </span><span class="pl-s1">-</span><span class="pl-c">			; /</span>

<span class="pl-s1">+</span>
<span class="pl-en">	LDA.b #MyCode</span><span class="pl-c">		; \ Place Parallel Mode Service Pointer</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3186</span><span class="pl-c">		;  |</span>
<span class="pl-en">	LDA.b #MyCode&gt;&gt;</span><span class="pl-c1">8</span><span class="pl-c">	;  |</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3187</span><span class="pl-c">		;  |</span>
<span class="pl-en">	LDA.b #MyCode&gt;&gt;</span><span class="pl-c1">16</span><span class="pl-c">	;  |</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3188</span><span class="pl-c">		; /</span>

<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-c1">01</span><span class="pl-c">		; \ Start Parallel Mode Service</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-en">318B</span><span class="pl-c">		; /</span></pre></div>
<p>Example code (actual parallel mode):</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">	PHB</span><span class="pl-c">			; \ Set up banks.</span>
<span class="pl-en">	PHK</span><span class="pl-c">			;  |</span>
<span class="pl-en">	PLB</span><span class="pl-c">			; /</span>

<span class="pl-en">.main_loop</span>
<span class="pl-en">	LDA</span> <span class="pl-c1">$</span><span class="pl-en">8B</span><span class="pl-c">			; \ If the parallel mode state</span>
<span class="pl-en">	</span><span class="pl-k">CMP</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-en">FF</span><span class="pl-c">		;  | is set to #$FF (end), shutdown</span>
<span class="pl-en">	BEQ .end</span><span class="pl-c">		; / the service.</span>

<span class="pl-en">	LDA</span> <span class="pl-c1">$</span><span class="pl-en">EF</span><span class="pl-c">			; \ Check if there's any graphics</span>
<span class="pl-en">	</span><span class="pl-k">CMP</span> <span class="pl-c1">$</span><span class="pl-en">EE</span><span class="pl-c">			;  | rotation request.</span>
<span class="pl-en">	BEQ .main_loop</span><span class="pl-c">		;  |</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-en">EF</span><span class="pl-c">			; /</span>

<span class="pl-en">	JSR .rotate</span><span class="pl-c">		; Rotate GFX (not included there)</span>
<span class="pl-en">	BRA .main_loop</span><span class="pl-c">		; Go to back main loop.</span>

<span class="pl-en">.end</span>
<span class="pl-en">	PLB</span><span class="pl-c">			; Restore bank</span>
<span class="pl-en">	RTL</span><span class="pl-c">			; Return.</span></pre></div>
<p>Personally this mode is extremely useful for rotating graphics, because
it takes SA-1's unused cycles and it does not cause slowdown. If there's
not enough time to rotate a GFX, instead of making the game get unstable
and slowdown, it will just reduce the rotation frame rate, which most
users will not actually notice. It can be also useful for you, for some
reason, want to for example decompress a GFX in the background without
freezing temporally the level or even you want to run a music engine
here. Use it freely! Remember that it's multi-threaded and your code
must be thread-safe with normal SA-1 operations and with the SNES CPU.
And when SNES CPU code is running together with Parallel Mode, the code
performance may reduce a bit to around 8 MHz, but still a very good
performance to explore while SA-1 CPU is not doing anything. And when
SNES is idle (i.e. finished processing a game frame), the code is
executed normally at 10.74 MHz.</p>
<h2>
<a id="user-content-sa-1-dma" class="anchor" href="#sa-1-dma" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SA-1 DMA</h2>
<p>There are a bunch of other useful features too, such as bit stream
and fast DMA which are only available while on SA-1 side.</p>
<p>The SA-1 DMA can transfer data from ROM to I-RAM (10 MHz (4x faster than SNES)),
from ROM to BW-RAM (5 MHz (2x faster)), from BW-RAM to I-RAM (5 MHz (2x faster))
and from I-RAM to BW-RAM (5 MHz (2x faster)). Although I-RAM &lt;-&gt; BW-RAM transfers
are 2x slower than ROM -&gt; I-RAM ones, you can still run SA-1 and DMA in parallel.</p>
<p>SA-1 DMA example (ROM-&gt;BW-RAM):</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA.b #%</span><span class="pl-c1">11000100</span><span class="pl-c"> 			; \ Enable DMA, DMA Priority, ROM-&gt;BWRAM</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2230</span><span class="pl-c">				; /</span>

<span class="pl-k">REP</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-c1">20</span><span class="pl-c">				; 16-bit Accum</span>
<span class="pl-en">LDA #Location</span><span class="pl-c"> 				; \ ROM source address</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2232</span><span class="pl-c">				; /</span>
<span class="pl-en">LDX #Bank</span><span class="pl-c"> 				; \ ROM source bank</span>
<span class="pl-en">STX</span> <span class="pl-c1">$</span><span class="pl-c1">2234</span><span class="pl-c">				; /</span>

<span class="pl-en">LDA #Size</span><span class="pl-c">				; \ Set size of transfer</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2238</span><span class="pl-c">				; /</span>

<span class="pl-en">LDA #Dest</span><span class="pl-c">				; \ BW-RAM destination address</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2235</span><span class="pl-c">				; /</span>
<span class="pl-en">LDX #BWRAM_Bank</span><span class="pl-c">				; \ BW-RAM destination bank (#$40 or #$41)</span>
<span class="pl-en">STX</span> <span class="pl-c1">$</span><span class="pl-c1">2237</span><span class="pl-c">				; / The DMA starts upon writing to $2237.</span>
<span class="pl-c">; Note that if the destination is I-RAM, then it'll start upon writing to $2236 instead.</span>

<span class="pl-en">.</span><span class="pl-k">Wait</span>
<span class="pl-en">LDX</span> <span class="pl-c1">$</span><span class="pl-en">318C</span><span class="pl-c">				; \ Wait for DMA flag.</span>
<span class="pl-en">BEQ .</span><span class="pl-k">Wait</span><span class="pl-c">				; /</span>
<span class="pl-en">LDX #</span><span class="pl-c1">$</span><span class="pl-c1">00</span><span class="pl-c">				; \ Clear the DMA flag</span>
<span class="pl-en">STX</span> <span class="pl-c1">$</span><span class="pl-en">318C</span><span class="pl-c"> 				; /</span>
<span class="pl-en">STX</span> <span class="pl-c1">$</span><span class="pl-c1">2230</span><span class="pl-c">				; Disable SA-1 DMA</span>

<span class="pl-en">SEP #</span><span class="pl-c1">$</span><span class="pl-c1">20</span><span class="pl-c"> 				; 8-bit Accum</span></pre></div>
<h2>
<a id="user-content-variable-length-processing" class="anchor" href="#variable-length-processing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Variable Length Processing</h2>
<p>Although I only used the Variable Length Bit Processing (bit stream)
feature once, here is an example how to use it (In Fixed Mode):</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">STZ</span> <span class="pl-c1">$</span><span class="pl-c1">2258</span><span class="pl-c">				; Set Fixed Mode</span>

<span class="pl-k">REP</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-c1">20</span><span class="pl-c">				; \ Set the address to start reading from</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">Address</span><span class="pl-c">				;  |</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2259</span><span class="pl-c">				;  |</span>
<span class="pl-en">LDX #</span><span class="pl-c1">$</span><span class="pl-en">Bank</span><span class="pl-c">				;  |</span>
<span class="pl-en">STX</span> <span class="pl-c1">$</span><span class="pl-en">225B</span><span class="pl-c">				;  |</span>
<span class="pl-en">SEP #</span><span class="pl-c1">$</span><span class="pl-c1">20</span><span class="pl-c">				; /</span>

<span class="pl-c">; Now let me explain. $2306 and $2307 contain</span>
<span class="pl-c">; a virtually "infinite" value from ROM</span>
<span class="pl-c">; that you can read (only 16-bit at once)</span>
<span class="pl-c">; and shift by the desired amount of bits to the right.</span>

<span class="pl-c">; To make a little easier, imagine that $2258 is a seek function, but it uses bits instead of bytes,</span>
<span class="pl-c">; and $230C/$230D is a read function, but without seek if fixed mode is used.</span>
<span class="pl-c">; It works like this:</span></pre></div>
<div class="highlight highlight-source-cs"><pre><span class="pl-en">bitStream</span> <span class="pl-smi">bs</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">BitStream</span>(<span class="pl-smi">romData</span>); 		<span class="pl-c"><span class="pl-c">//</span> romData is a byte array.</span>

<span class="pl-k">int</span> <span class="pl-smi">someBits</span> <span class="pl-k">=</span> <span class="pl-smi">bs</span>.<span class="pl-en">ReadByte</span>() <span class="pl-k">&amp;</span> <span class="pl-c1">0x0F</span>;		<span class="pl-c"><span class="pl-c">//</span> read 4 bits</span>
<span class="pl-smi">bs</span>.<span class="pl-en">Seek</span>(<span class="pl-c1">4</span>);					<span class="pl-c"><span class="pl-c">//</span> seek / shift 4 bits</span>

<span class="pl-k">int</span> <span class="pl-smi">moreBits</span> <span class="pl-k">=</span> <span class="pl-smi">bs</span>.<span class="pl-en">ReadByte</span>() <span class="pl-k">&amp;</span> <span class="pl-c1">0x07</span>;		<span class="pl-c"><span class="pl-c">//</span> read 3 bits</span>
<span class="pl-smi">bs</span>.<span class="pl-en">Seek</span>(<span class="pl-c1">3</span>);					<span class="pl-c"><span class="pl-c">//</span> seek / shift 3 bits</span></pre></div>
<p>The code above, translated into ASM, would look like this:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-en">230C</span>
<span class="pl-k">AND</span><span class="pl-en"> #%BitsToMask</span>
<span class="pl-c1">[handle value]</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-en">BitsToSeek</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2258</span></pre></div>
<p>You can keep doing this until you want to stop the reading process.</p>
<p>Here's a simple practical example.
In LZ2, the syntax of the header looks like this (in bits):</p>
<pre><code>bits
76543210
CCCLLLLL

CCC:   Command bits
LLLLL: Length
</code></pre>
<p>So <code>CCC</code> is the command and <code>LLLLL</code> is the length.
To read that using bit stream, you can do this:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-en">230C</span>
<span class="pl-k">AND</span><span class="pl-en"> #%</span><span class="pl-c1">00011111</span>
<span class="pl-c">; Handle length value</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">05</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2258</span><span class="pl-c"> ; Seek 5 bits, now CCCLLLLL -&gt; ?????CCC</span>

<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-en">230C</span>
<span class="pl-k">AND</span><span class="pl-en"> #%</span><span class="pl-c1">00000111</span>
<span class="pl-c">; Handle command value</span>
<span class="pl-en">LDA #</span><span class="pl-c1">$</span><span class="pl-c1">03</span><span class="pl-c"> ; Shift 3 bits now ?????CCC -&gt; ????????</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">2258</span>

<span class="pl-c">; Do stuff and/or keep reading, etc.</span></pre></div>
<p>Well, that was all I could do about examples. Now have fun combinating
all features!</p>
<p>WARNING: bsnes 0.7x appears to have a bug with the bit stream, as the bank
switching doesn't work while using the Variable Length Bit feature,
thus making it impossible to access the 5-8MB area. Be careful!</p>
<h2>
<a id="user-content-virtual-bw-ram" class="anchor" href="#virtual-bw-ram" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Virtual BW-RAM</h2>
<p>Now, there's still one feature that I haven't explained yet, so it's time to
explain it, I guess. I said earlier that SA-1 can access banks <code>$60</code>-<code>$6F</code>,
aka the "Virtual" BW-RAM, right?</p>
<p>The "Virtual" BW-RAM (I'll name as VRAM, okay?) is a BW-RAM mirror, but with a
special added feature. The special feature of this area is that it only stores
certain bits to the actual BW-RAM: 4 or 2 bits, depending on the value in <code>$223F</code>.
If bit 7 of that one is clear, the VRAM will write 4 bits, otherwise only 2 bits
are used from each address. It basically works like this:</p>
<div class="highlight highlight-source-c"><pre>$<span class="pl-c1">40</span>:<span class="pl-c1">0000</span> = ($<span class="pl-c1">60</span>:<span class="pl-c1">0000</span> &lt;&lt; <span class="pl-c1">0</span>) | ($<span class="pl-c1">60</span>:<span class="pl-c1">0001</span> &lt;&lt; <span class="pl-c1">4</span>);</pre></div>
<p>Or if bit <code>7</code> of <code>$223F</code> is set:</p>
<div class="highlight highlight-source-c"><pre>$<span class="pl-c1">40</span>:<span class="pl-c1">0000</span> = ($<span class="pl-c1">60</span>:<span class="pl-c1">0000</span> &lt;&lt; <span class="pl-c1">0</span>) | ($<span class="pl-c1">60</span>:<span class="pl-c1">0001</span> &lt;&lt; <span class="pl-c1">2</span>) | ($<span class="pl-c1">60</span>:<span class="pl-c1">0002</span> &lt;&lt; <span class="pl-c1">4</span>) | ($<span class="pl-c1">60</span>:<span class="pl-c1">0003</span> &lt;&lt; <span class="pl-c1">6</span>);</pre></div>
<p>Similarly, in order to write to <code>$40:0001</code>, you'll need to use both <code>$60:0002</code>
and <code>$60:0003</code> if bit 7 of <code>$223F</code> is clear, or else you'll want <code>$60:0004</code>, <code>$60:0005</code>,
<code>$60:0006</code> and <code>$60:0007</code>.</p>
<p>So, if you write <code>#$0F</code> to <code>$60:0000</code>, it'll do:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">400000</span>
<span class="pl-k">AND</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-en">F0</span>
<span class="pl-en">ORA</span> <span class="pl-c1">$</span><span class="pl-c1">600000</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">400000</span></pre></div>
<p>then, if <code>$60:0001</code> is written:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">600001</span>
<span class="pl-k">AND</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-en">0F</span>
<span class="pl-en">ASL #</span><span class="pl-c1">4</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">00</span>
<span class="pl-en">LDA</span> <span class="pl-c1">$</span><span class="pl-c1">400000</span>
<span class="pl-k">AND</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-en">0F</span>
<span class="pl-en">ORA</span> <span class="pl-c1">$</span><span class="pl-c1">00</span>
<span class="pl-en">STA</span> <span class="pl-c1">$</span><span class="pl-c1">400000</span></pre></div>
<p>and if bit 7 of <code>$223F</code> is set, it'll work similarly,
but with <code>$60:0000</code>-<code>$60:0003</code> and using 2 bits from each address.</p>
<p>Of course, making use of this VRAM will speed up the process of storing
a few bits to a RAM address, but why would we use this?
For the one and only reason: Character Conversion DMA.</p>
<h2>
<a id="user-content-character-conversion-dma" class="anchor" href="#character-conversion-dma" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Character Conversion DMA</h2>
<p>But what is Character Conversion DMA?
You know, some games managed to use get some pretty nice effects such as rotating, scaling...
But you can't do that directly in SNES file format, because it's a bit too complex
to change its pixels.</p>
<p>To work around that, you will need to create a linear bitmap in RAM, then set all
the pixels and effects and convert the data into SNES format to store it into VRAM.
But the conversion is really tricky and to help that, SA-1 has a really great feature,
which happens to be the most complex DMA available, used to convert bitmaps into SNES
format and AT SAME TIME upload it in VRAM. This is done thanks to a combination of 2 DMAs,
the SNES DMA and SA-1 DMA. While the SNES DMA reads the BW-RAM and transfers data from
it to VRAM, the SA-1 DMA reads from BW-RAM, converts the data to SNES format and "gives"
to SNES, bypassing the value that the SNES reads from BW-RAM. All of this is done at the
same time and during NMI. So with Character Conversion DMA you can make a Framebuffer in
BW-RAM and upload into VRAM in a very easy and fast way, since the transfers will still
take the same time: 1 cycle per byte, except that SA-1 DMA converts the data simultaneously.</p>
<p>Fortunately, I've already accomplished the harder tasks and my patch already handles
Character Conversion DMA for you.
I created a table, which works much more like the OAM/Sprite Tiles one:</p>
<table><tbody>
<tr>
<td><code>$3190+x</code></td>
<td>Character Conversion Settings. 80+ will act like a normal DMA transfer.</td>
</tr>
<tr>
<td><code>$3191+x</code></td>
<td>VRAM target (low).</td>
</tr>
<tr>
<td><code>$3192+x</code></td>
<td>VRAM target (high).</td>
</tr>
<tr>
<td><code>$3193+x</code></td>
<td>Data location (low).</td>
</tr>
<tr>
<td><code>$3194+x</code></td>
<td>Data location (high).</td>
</tr>
<tr>
<td><code>$3195+x</code></td>
<td>Data location (bank).</td>
</tr>
<tr>
<td><code>$3196+x</code></td>
<td>Length of data (low)</td>
</tr>
<tr>
<td><code>$3197+x</code></td>
<td>Length of data (high)</td>
</tr>
</tbody></table>
... Up to 10 slots, which means that the table will need 80 bytes.
<p><code>$317F</code> holds the number of used slots. If the number is 0xA (10), then all
slots are being used and no character conversion DMA will happen. To index the table
and enable the DMA, do this:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">SetTable:</span>
<span class="pl-en">	LDA</span> <span class="pl-c1">$</span><span class="pl-en">317F</span><span class="pl-c">			; Load Character Conversion DMA slot count</span>
<span class="pl-en">	</span><span class="pl-k">CMP</span><span class="pl-en"> #</span><span class="pl-c1">$</span><span class="pl-en">0A</span><span class="pl-c">			; \ if all slots are used, skip</span>
<span class="pl-en">	BEQ .End</span><span class="pl-c">			; /</span>
<span class="pl-en">	ASL</span><span class="pl-c">				; \ multiply the count by 8</span>
<span class="pl-en">	ASL</span><span class="pl-c">				;  |</span>
<span class="pl-en">	ASL</span><span class="pl-c">				; /</span>
<span class="pl-en">	TAX</span><span class="pl-c">				; and use it as an index</span>

<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">SETTINGS</span><span class="pl-c">			; \ Set $2231 value</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3190</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			; /</span>

<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">VRAM_Low</span><span class="pl-c">			; \ Set VRAM Destination address</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3191</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			;  |</span>
<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">VRAM_High</span><span class="pl-c">			;  |</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3192</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			; /</span>

<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">BWRAM_Low</span><span class="pl-c">			; \ Set	the BW-RAM address</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3193</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			;  | (The pointer of the Bitmap)</span>
<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">BWRAM_High</span><span class="pl-c">		;  |</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3194</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			;  |</span>
<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">BWRAM_Bank</span><span class="pl-c">		;  |</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3195</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			; /</span>

<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">Length_Low</span><span class="pl-c">		; \ Set the length of the transfer</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3196</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			;  | (Size of the bitmap)</span>
<span class="pl-en">	LDA #</span><span class="pl-c1">$</span><span class="pl-en">Length_High</span><span class="pl-c">		;  |</span>
<span class="pl-en">	STA</span> <span class="pl-c1">$</span><span class="pl-c1">3197</span><span class="pl-s1">,</span><span class="pl-en">x</span><span class="pl-c">			; /</span>

<span class="pl-en">	</span><span class="pl-k">INC</span> <span class="pl-c1">$</span><span class="pl-en">317F</span><span class="pl-c">			; Increase the number of slots used.</span>
<span class="pl-en">.End</span>
<span class="pl-en">	RTS</span><span class="pl-c">				; Return</span></pre></div>
<p>You will also need to learn how register <code>$2231</code> and SA-1 Bitmap work though.
Check out the SNES Dev. Book II, Super Accelerator (SA-1) -&gt; Character Conversion.
You may find the file on section "Links".</p>
<h2>
<a id="user-content-detecting-sa-1" class="anchor" href="#detecting-sa-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Detecting SA-1</h2>
<p>There are a few methods of detecting if the SA-1 is present.</p>
<h3>
<a id="user-content-detecting-sa-1-chip" class="anchor" href="#detecting-sa-1-chip" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Detecting SA-1 chip</h3>
<p>You can detect if the SA-1 chip is present by checking if ROM address $00FFD5 is $23 and $00FFD6 is $35</p>
<p>It's a common practice of testing the presence of the chip by adding the following header:</p>
<pre><code>!sa1 = 0

if read1($00ffd5) == $23
	!sa1 = 1
endif
</code></pre>
<h3>
<a id="user-content-detecting-sa-1-pack" class="anchor" href="#detecting-sa-1-pack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Detecting SA-1 Pack</h3>
<p>Since SA-1 Pack v1.40 it's possible to check if SA-1 Pack is present and which version is installed on ROM.</p>
<p>Address $0084C0 will contain $5A123 (or $05A123) if SA-1 Pack v1.40 or newer is present.
Address $0084C3 will contain the currently installed version.</p>
<blockquote>
<p><strong>Note</strong>:
5A123 references the 5F5A123 name marking of the chip.</p>
</blockquote>
<p>This is useful for ensuring your patch can only be installed on specific SA-1 Pack versions.</p>
<p>You can detect if SA-1 Pack v1.40 is present by doing the following:</p>
<pre><code>assert read3($0084C0) == $5A123, "SA-1 Pack is required"
assert read1($0084C3) &gt;= 140, "SA-1 Pack v1.40 or newer is required"
</code></pre>
<p>Another example is checking if a determined version is installed, e.g. the hypothetical version 1.55:</p>
<pre><code>assert read3($0084C0) == $5A123, "SA-1 Pack is required"
assert read1($0084C3) == 155, "This code only works with SA-1 Pack v1.55"
</code></pre>
<p>You can even check if a specific major version is being used:</p>
<pre><code>assert read3($0084C0) == $5A123, "SA-1 Pack is required"
assert read1($0084C3)/10 == 16, "This code only works with SA-1 Pack 1.6x versions"
</code></pre>
<blockquote>
<p><strong>Note</strong>:
As a workaround for SA-1 versions older (or earlier) than 1.40, you can check if $FFD5 is $23 and $84C0 is $EAEAEA</p>
</blockquote>

</body>
</html>
